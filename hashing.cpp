#include<iostream>
#include<vector>
#include<unordered_map>
using namespace std;
// int main()
// {
// //     unordered_map <string,int> map;
// //     //insert
// //     pair<string,int>p("abc",1);
// //     map.insert(p);
// //     map["xyz"]=2;
// //     //find or access
// //     cout<<map["xyz"]<<endl;
// //     cout<<map.at("abc")<<endl;
// //     //if key does not exist then if we use square bracket it will not give error rather insert 0 therre whereas .at will give error
// //     //check presence
// //     cout<<map.size()<<endl;
// //     if(map.count("ghi")>0)
// //     {
// //         cout<<"present"<<endl;
// //     }
// //     //erase
// //     map.erase("abc");
// //     cout<<map.size()<<endl;


// }
// // // ll wil take 0(n)
// // //bst will take 0(logn)//ordered map
// //removing duplicate from array using msps
// vector<int> dupli(int *a,int n)
// {
//     unordered_map<int,bool> map;
//     vector<int> dup;
//     for(int i=0;i<n;i++)
//     {
//         if(map.count(a[i])>0)
//         {
//             continue;
//         }
//         else{
//         dup.push_back(a[i]);
//         map[a[i]]=true;
//         }
//     }
//     return dup;
// }
int main()
{
    // int a[10]={1,2,2,1,3,4,6,4,3,6};
    // vector<int>v=dupli(a,10);
    // for(int i=0;i<v.size();i++)
    // {
    //     cout<<v[i]<<endl;
    // }
    //iterator
    // unordered_map<string,int>map;
    // map["abc1"]=1;
    // map["abc2"]=2;
    // map["abc3"]=3;
    // map["abc4"]=4;
    // map["abc5"]=5;
    // map["abc6"]=6;
    // unordered_map<string,int> :: iterator it=map.begin();
    // while(it!=map.end())
    // {
    //     cout<<"key is"<<it->first<<"value is"<<it->second<<endl;
    //     it++;
    // }
    // vector<int>v;
    // v.push_back(1);
    // v.push_back(2);
    // v.push_back(3);
    // v.push_back(4);
    // v.push_back(5);
    // v.push_back(6);
    // vector<int>::iterator it1=v.begin();
    // while(it1!=v.end())
    // {
    //     cout<<*it1<<endl;
    //     it++;
    // }

    // map.erase(it1,it1+4);
    //collison handling
    //closed hashing also calles seperate chain
    //open hashing/addressing
    //hi(a)=hf(a)+f(i);
    //f(i)=i linear hashing
    //f(i)=i^2 quadratic hashing
    //f(i)=another hash function double hashing



    

   

}
 